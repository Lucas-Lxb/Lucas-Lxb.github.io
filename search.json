[{"title":"String类的特性","url":"/2024/08/04/String%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7/","content":"问题描述​\t下面程序运行的结果是什么？尝试画出内存布局图。\n\n\npublic class StringExercise02 &#123;    String str = new String(&quot;lxb&quot;);    final char[] ch = &#123;&#x27;j&#x27;,&#x27;a&#x27;,&#x27;v&#x27;,&#x27;a&#x27;&#125;;    public void change(String str,char ch[]) &#123;        str = &quot;java&quot;;        ch[0] = &#x27;h&#x27;;    &#125;    public static void main(String[] args) &#123;        StringExercise02 ex = new StringExercise02();        ex.change(ex.str,ex.ch); //①        System.out.print(ex.str + &quot; and &quot;);        System.out.println(ex.ch);    &#125;&#125;\n\n\n解决方法一、方法执行时分析public void change(String str,char ch[]) &#123;        str = &quot;java&quot;;\t//代码②        ch[0] = &#x27;h&#x27;;\t//代码③    &#125;\n\n​\t在执行代码①处时，ex.str 和 ex.ch 被传递给change方法，由于二者均为引用数据类型(数组类型和String类型)，因而传入 change 方法时，会直接使得形参 str 指向ex对象的 str 和 ch 属性在堆中的地址，后开始执行该方法：\n由于代码②处将字符串常量赋值给 str，因而会在常量池中创建 “java” 对象，并将 str 指向该处于常量池中的对象，因而上述图中的虚线断裂，箭头重新指向常量池中的 “java” ；\n由于 ch 并未重新赋值，而是直接在原来的基础上对原数组进行修改，因而ch的指向不改变，但是该数组的内容发生改变。\n二、方法执行后分析​\t由于在执行该方法时 JVM 会在栈中创建 change 栈，在该方法执行完毕之后进行销毁，因此该方法的形参 str 和 ch 均被销毁，并返回主栈。此时 ex 对象的 str 属性并未改变，为 “lxb” ；ch 属性则发生变化，变为 “hava” ,因而最终输出为 lxb and hava.\n","categories":["码农搬砖"],"tags":["Java基础"]},{"title":"一生一芯","url":"/2024/08/13/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/","content":"一、Linux环境搭建1.gdb调试\n\n1.gdb -q Filename 进入gdb调试器\n2.（gdb）b 3\t\t\t在第三行添加断点\tbreakpoint\n3.(gdb) run\t\t\t\t执行程序\n4.(gdb)whatis iNum\t查看iNum的数据类型\n5.(gdb) c\t\t\t\t\t继续执行程序（直到下一个断点或者之后没有断点就运行完整个程序）\n6.(gdb)\tn\t\t\t\t一步一步执行程序\n7.(gdb) p iNum\t\t输出iNum值\t\t\t\t\t\t\t（gdb中变量的值是每一步执行之前的数字）\n2.Makefile从源码到可执行文件的四个阶段：\n\n预处理(.c\t-&gt;\t.i)\ngcc -E test.c -o test.i\n\n\t\n\n编译   (.i     -&gt;    .s)                 得到汇编语言代码\ngcc -S test.i -o test.s\n\n\n汇编   (.s    -&gt;    .o)                 得到机器语言代码\ngcc -c test.s -o test.o\n\n\n链接   (.o    -&gt;    )                    得到可执行文件\ngcc test.o -o test\n\n\n\ngcc(选项)(参数)：\n​\t-o：指定生成的输出文件；​\t-On：n为数字1~3，使用编译优化级别n编译程序；​\t-E：仅执行编译预处理；​\t-S：将C代码转换为汇编代码；​\t-Wall：显示警告信息；​\t-c：仅执行编译操作，不进行链接操作。\n3.tmux使用Ctrl\t+\tb,\tshift\t+\t%\t新建左右窗格\nCtrl\t+\tb,\tshift\t+\t“\t新建上下窗格\nCtrl\t+\tb,\tx\t删除当前窗格\n4.编译nemu的坑​\t\t\t\t\t\tmake menuconfig命令后出现如下情况：\n/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/scripts/config.mk:20: Warning: .config does not exists!/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/scripts/config.mk:21: To build the project, first run &#x27;make menuconfig&#x27;.\n\nCC confdata.cCC expr.cCC preprocess.cCC symbol.cCC util.cYACC build/parser.tab.hmake[1]: bison: 没有那个文件或目录make[1]: *** [Makefile:27：build/parser.tab.h] 错误 127make: *** [/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/scripts/config.mk:39：/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/tools/kconfig/build/mconf] 错误 2\n\n解决方法：要安装词法分析和语法分析工具\tflex和bison\n二、搭建verilator仿真环境1.【一生一芯】搭建verilator仿真环境 - 老吴家的小阿哲 - 博客园 (cnblogs.com)2.verilator探幽(1)一个简单的例子1.将verilog代码写入文件top.v\n2.将**C++**代码写入文件sim_main.cpp\n3.使用下面的命令来运行Verilator:\nverilator --cc --exe --build -j 0 -Wall sim_main.cpp top.v\n\n4.使用\t.&#x2F;obj_dir&#x2F;Vtop\t来运行Verilator生成的可执行程序\n(2)稍微复杂的例子在Verilog中，assign 是一个关键字，用于为信号赋值\n(一)在C++代码中设置跟踪，创建波形文件\n\n1.编写top.v:\nmodule top (    input a,    input b,    output f);    assign f = a ^ b;endmodule\n\n2.编写main.cpp：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;assert.h&gt;#include &quot;verilated_vcd_c.h&quot; // 生成vcd文件使用#include &quot;Vtop.h&quot;#include &quot;verilated.h&quot;int main (int argc, char **argv) &#123;    if (false &amp;&amp; argc &amp;&amp; argv) &#123;&#125;    const std::unique_ptr&lt;VerilatedContext&gt; contextp&#123;new VerilatedContext&#125;; //创建一个动态分配的 VerilatedContext 对象，并使用 std::unique_ptr 来确保在不再需要时自动释放内存    std::unique_ptr&lt;Vtop&gt; top&#123;new Vtop&#123;contextp.get()&#125;&#125;;    contextp-&gt;commandArgs(argc, argv);    contextp-&gt;traceEverOn(true); // 生成波形文件使用，打开追踪功能    VerilatedVcdC* ftp = new VerilatedVcdC; // vcd对象指针    top-&gt;trace(ftp, 0); // 0层    ftp-&gt;open(&quot;wave.vcd&quot;); //设置输出的文件wave.vcd    int flag = 0;    while (!contextp-&gt;gotFinish() &amp;&amp; ++flag &lt; 20)     &#123;        int a = rand() &amp; 1;        int b = rand() &amp; 1;        top-&gt;a = a;        top-&gt;b = b;        top-&gt;eval();        printf(&quot;a = %d, b = %d, f = %d\\n&quot;, a, b, top-&gt;f);        assert(top-&gt;f == (a ^ b));\t//验证top-&gt;f == (a ^ b)，若结果为假，程序终止，并输出错误信息        contextp-&gt;timeInc(1); // 时间+1，推动仿真时间         ftp-&gt;dump(contextp-&gt;time()); // dump wave    dump 方法通常用于将当前时间的信号状态写入到波形文件中    &#125;    top-&gt;final();    ftp-&gt;close(); // 必须有    return 0;&#125;\n\n3.使用如下命令：\nverilator --cc --exe --build -Wall --trace top.v main.cpp\n\n4.执行生成的Vtop可执行文件\n./obj_dir/Vtop\n\n5.shell观察波形\ngtkwave wave.vcd\n\n\n\n(二)在Verilog代码中设置跟踪，创建波形文件\n\n1.top.v:\nmodule top (    input a,    input b,    output f);    assign f = a ^ b;initial begin    if ($test$plusargs(&quot;trace&quot;) != 0) begin\t\t\t//在仿真开始时检查命令行参数，如果存在 &quot;trace&quot; 参数，则设置波形文件并将相关的信号状态写入到波形文件中         $display(&quot;[%0t] Tracing to wave.vcd...\\n&quot;, $time);         $dumpfile(&quot;wave.vcd&quot;);         $dumpvars();      end      $display(&quot;[%0t] Model running...\\n&quot;, $time);   endendmodule\n\n2.main.cpp:\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;assert.h&gt;#include &quot;Vtop.h&quot;#include &quot;verilated.h&quot;int main (int argc, char **argv) &#123;    if (false &amp;&amp; argc &amp;&amp; argv) &#123;&#125;    const std::unique_ptr&lt;VerilatedContext&gt; contextp&#123;new VerilatedContext&#125;;    std::unique_ptr&lt;Vtop&gt; top&#123;new Vtop&#123;contextp.get()&#125;&#125;;    contextp-&gt;commandArgs(argc, argv);    contextp-&gt;traceEverOn(true); // 生成波形文件使用，打开追踪功能    int flag = 0;    while (!contextp-&gt;gotFinish() &amp;&amp; ++flag &lt; 20) &#123;        int a = rand() &amp; 1;        int b = rand() &amp; 1;        top-&gt;a = a;        top-&gt;b = b;        top-&gt;eval();        printf(&quot;a = %d, b = %d, f = %d\\n&quot;, a, b, top-&gt;f);        assert(top-&gt;f == (a ^ b));        contextp-&gt;timeInc(1); // 时间+1，推动仿真时间    &#125;    top-&gt;final();    return 0;&#125;\n\n3.使用如下命令：\nverilator --cc --exe --build -Wall --trace top.v main.cpp\n\n4.执行生成的Vtop可执行文件\n./obj_dir/Vtop\n\n5.shell观察波形\ngtkwave wave.vcd\n\n三、Linux入门教程1.基本命令\nfind . -name “*.[c]” ———查找当前目录下的.c文件\n\ngrep “\\bint i\\b”  a.c   查找文件中定义变量i的位置\t\t\t—————-模式”\\bint i\\b”包含了单词边界锚点（\\b）在”int i”周围。这些锚点指定”int i”应该是一个完整的单词，而不是更大单词的一部分。\n\nwc     a.c  返回该文件的行数\t单词数\t字符数\t\t\t\t要求为文本文件\n\ncp\tsource\tdestination     复制命令      把左边文件的内容复制到右边\n\n\n2.Linux\tvs.\tWindows1.有些简单的事Windows GUI反而做不好比较两个文件是否相同\nLinux的解决方案：\n\n文本文件的解决方案\nvimdiff\tfile1\tfile2 \n\n非文本文件的解决方案\ndiff\tfile1\tfile2\n\n很大的文件\nmd5sum\tfile1\tfile2\n\n2.有些复杂的事Windows GUI几乎做不了列出一个项目中所有被包含的头文件\nLinux的解决方案：通过管道进行解决\nfind\t.\t-name  &quot;*.[ch]&quot;\t|\txargs\tcat\t|\tgrep  &quot;^#include&quot;  |\tsort\t|\tuniq\n\n3.工具如何运行(1)一个重要的踪迹工具：strace\nsystem\tcall strace,记录程序运行过程中的系统调用信息\n系统调用：一个由操作系统来执行的特殊的函数调用\n\n在Linux中,Path是一个非常重要的概念,它是用来定位系统中各种可执行文件、命令和脚本的路径。\nstrace bash -c &quot;PATH = &#x27;aaa:bbb:ccc&#x27; ls&quot;\t\t//整个命令的目的是使用strace追踪Bash shell在将PATH环境变量设置为&#x27;aaa:bbb:ccc&#x27;后执行ls命令时所发起的系统调用。\n\n(2)用户与man交互在 man 命令下进行手册的阅读时，可以使用一些快捷键和搜索命令来进行快速搜索。以下是一些建议：\n使用/进行搜索：\n\n- 在 `man` 页面中按 `/` 键，然后输入你要搜索的关键词，按回车。`man` 会定位到第一个匹配的文本。\n- 按 `n` 键继续查找下一个匹配，按 `N` 键查找上一个匹配。\n  ### (3)强大的shell1.通配符\t*\t（任意长度的任意字符串）\t|\t？\t（任意一个字符）\t|\t[...](集合中的任意一个字符)2.括号扩展&#123;...&#125;（例：echo Hello-&#123;a,bb,ccc&#125;-&#123;1,2&#125;!）---------&gt;------&gt;输出结果为：Hello-a-1! Hello-a-2! Hello-bb-1! Hello-bb-2! Hello-ccc-1! Hello-ccc-2!### (3)使用alias为常用命令设置别名```calias ls = &quot;ls --color&quot;    可以写入~/.bashrc文件，打开终端时生效，无需重复设置：source ~/.bashrc\n\n\n\n(4)任务管理1.查看任务管理器：ps aux\t\t\t\t——-&gt;   静态命令，只显示在命令运行时的瞬时数据。\n\nps 是一个用于报告当前系统进程信息的命令\naux 选项表示以详细的方式显示所有用户的所有进程\n提供了基本的进程信息，如进程ID（PID）、CPU利用率、内存使用、启动时间等\n\n\n\n2.top 提供了实时动态更新的系统监视器\n3.htop 是 top 的增强版，提供了更直观的界面和更多功能\n(5)输入输出重定向已知Linux上的程序在运行时默认打开了3个文件，通过“文件描述符”来编号：\n\n0号文件 - 标准输入（默认为当前终端）\n1号文件 - 标准输出（默认为当前终端）\n2号文件 - 标准错误（默认为当前终端）\n\n1.向文件追加输出\nls &gt;&gt; result.txt\n\n2.将标准错误重定向到文件\nls 2&gt; /dev/null...\n\n3.将标准输入重定向到文件，无需手动输入\nsort &lt; result.txt\n\n(6)管道：工具间组合的秘诀管道 &#x3D; 一个用于连接程序间输入输出的缓冲区\nxargs:一个特殊的命令，可以将标准输入转变为命令的参数\n\n自制CPU主频监视器\n\nwatch -n 1 &quot;cat /proc/cpuinfo | grep MHz | awk\t&#x27;&#123;print \\$1\tNR\t\\$3\t\t\\$4\t\t\\$2&#125;&#x27;&quot;\n\nLinux中可执行文件为ELF文件\n4.如何学习Linux最重要的Linux命令：\nmanman man - 学习如何RTFMman 3 printf\t-\t学习如何使用库函数printfman -k xxx\t检索含有关键字含有xxx的命令\n\n\n","tags":["Linux"]},{"title":"计算理论导引","url":"/2024/03/18/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AF%BC%E5%BC%95/","content":"第一部分\t自动机与语言\n\n\n第一章\t正则语言1.1有穷自动机1.1.1 \t有穷自动机的形式化定义有穷自动机是一个5元组（Q，Σ，δ，q0，F）\n\nQ是一个有穷集合，称为状态集\n\nΣ是一个有穷集合，称为字母表\n\nδ：Q×Σ-&gt;Q，是转移函数\n\nq0∈Q，是起始状态\n\nF含于Q，是接受状态集\n\n\n1.1.2\t计算的形式化定义设M &#x3D; （Q，Σ，δ，q0，F）是一台有穷自动机，W &#x3D; W1W2W3…Wn是一个字符串并且其中任意wi是字母表Σ的成员。如果存在Q中的状态序列r0,r1,…,rn,满足下述条件：\n\nr0 &#x3D; q0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t机器从开始状态开始\nδ（ri,W(i + 1)） &#x3D; r(i + 1),i &#x3D; 0,…,n - 1            机器按照转移函数从一个状态到一个状态\nrn∈F                                                                如果机器结束在接受状态，则接受它的输入\n\n则M接受串W\n如果A &#x3D; {W | M接受W}，则称M识别语言A\n如果一个语言被一台有穷自动机识别，则称它为正则语言。\n1.1.3\t设计有穷自动机\n给每一种可能的字符串信息设计一个状态\n通过观察如何根据读到的符号从一种可能性到另一种可能性来设计转移\n接下来，把起始状态设置为对应于到现在为止还没有看到与任何符号（空串ε）相关联的可能性的状态\n\n1.1.4\t正则运算设A和B是两个语言，定义正则运算并、连接和星号如下：\n\n并：A∪B &#x3D; {x | x∈A或x∈B}\n连接：A▪B &#x3D; {xy | x∈A且y∈B}\n星号：A* &#x3D; {x1x2x3…xk | k &gt;&#x3D; 0 且每一个xi∈A}          ——&gt;一元运算\n\n一般来说，如果把某种运算应用于一个对象集合的成员得到的对象仍在这个集合中，则称这个对象集合在该运算下封闭。\n1.2\t非确定性非确定性是确定性的推广-&gt; 因此每一台确定性有穷自动机自动地是一台非确定性有穷自动机\nNFA与DFA的不同点：\n\n在NFA中，一个状态对应于字母表中的每一个符号可能有0个、1个或多个射出的箭头\n在DFA上，转移箭头上的标号是取自字母表中的符号；NFA中则可以取自ε\n一般来说，NFA的箭头可以标记字母表中的符号或ε。从一个状态可能射出0个、1个或多个带有标号ε的箭头\n\n可以把非确定性看做是若干独立的“过程”或“线程”，即能同时运行的一类**并行运算**，如果这些子过程至少有一个接受，那么整个计算接受。\n1.2.1 \t非确定性有穷自动机的形式化定义非确定性有穷自动机是一个5元组（Q，Σ，δ，q0，F）\n\nQ是一个有穷集合，称为状态集\nΣ是一个有穷集合，称为字母表\nδ：Q×（Σ∪{ε}）-&gt;（Q的幂集），是转移函数\nq0∈Q，是起始状态\n\n1.2.1\tNFA与DFA的等价性\n\n","categories":["理论知识"],"tags":["计算理论"]},{"title":"test","url":"/2024/08/13/test/","content":"\n测试~~\n\n    依然连仿真框架都没有, 真寒酸\n    我们之所以设置这部分的实验内容，是为了让大家知道...\n    \n        遇到系统性的bug，肯定消不出去...\n        离开了讲义，就什么都做不了...\n        一个很现实的场景是...\n    \n\n\n\n    如果你想使用Chisel\n    \n        cd ysyx-workbench\n        bash init.sh npc-chisel\n    \n    上述命令会将 npc 目录中的文件换成一个Chisel开发环境...\n\n\n\n\n\n\n"},{"title":"树莓派opencv-python踩坑记录","url":"/2024/04/04/%E6%A0%91%E8%8E%93%E6%B4%BEopencv-python%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"1.’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突修改为：安装版本为 python3.8 与 Opencv-python4.1.2.\n\n\n\n\n2.使用pip安装软件包时出现SSL验证失败问题：pip版本在20.3以上时会出现此错误修改：\n法一:下载pip版本为20.2.4\npython -m pip install pip==20.2.4 -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.compython -m pip install pip==20.2.4 -i http://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com\n\n法二：修改pip源\n修改为（以下任意一项） ———————–由于网速限制可能要多试几遍（我试了很多遍…….）\n\nhttp://mirrors.aliyun.com/pypi/simple/\n- ```  http://pypi.douban.com/simple\n\n\n\n注：树莓派所安装操作系统为DeBian 11.\n3.apt-get修改国内源（23.10 mantic版本）\n\n\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-backports main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ mantic-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ mantic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-proposed main restricted universe multiverse\n\n\n无法获得锁：&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-fronted\n\n解决方案:\nsudo rm /var/lib/dpkg/lock-frontendsudo rm /var/lib/dpkg/locksudo rm /var/cache/apt/archives/lock\n\n都运行一遍，具体也不知道哪条起了作用。\n出现以下错误：\nError:Could not build wheels for opencv-python ,which is required to install pyproject.toml-based projects------&gt;安装poetry------&gt;运行poetry init命令  #获得pyproject.toml文件------&gt;运行poetry install命令 #得到项目内文件的依赖\n\nPoetry 是一个用于管理 Python 项目依赖、虚拟环境和打包发布的工具。它通过一个名为 `pyproject.toml` 的配置文件来管理项目。使用 Poetry，你可以方便地定义项目的依赖关系、版本约束和脚本命令，并且它提供了一组命令来执行各种常见任务，例如安装依赖、创建虚拟环境、构建项目等。Poetry 是一个用于管理 Python 项目依赖、虚拟环境和打包发布的工具。它通过一个名为 pyproject.toml 的配置文件来管理项目。使用 Poetry，你可以方便地定义项目的依赖关系、版本约束和脚本命令，并且它提供了一组命令来执行各种常见任务，例如安装依赖、创建虚拟环境、构建项目等。以下是一些常用的 Poetry 命令：poetry init 是一个用于初始化 Python 项目的命令，它使用 Poetry 工具。Poetry 是一个 Python 包管理工具和项目管理工具，它可以帮助你管理项目依赖关系和构建工具。#当你运行 poetry init 命令时，它会引导你完成创建一个新的 Python 项目的过程。它会询问一些问题，如项目名称、版本、作者、项目依#赖等，并生成一个 pyproject.toml 文件，用于描述你的项目和其依赖关系。poetry new: 创建一个新的 Python 项目。poetry install: 安装项目的依赖。poetry add: 添加新的依赖项到项目。poetry remove: 从项目中移除依赖项。poetry update: 更新项目的依赖项。poetry run: 在虚拟环境中运行项目中定义的脚本命令。poetry shell: 进入项目的虚拟环境。poetry build: 构建项目。poetry publish: 发布项目到包索引。poetry config: 配置 Poetry 的设置。\n\n","categories":["折腾Linux"],"tags":["树莓派"]}]