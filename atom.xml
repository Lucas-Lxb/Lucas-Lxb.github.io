<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep</title>
  
  <subtitle>Hexo theme keep quick starter</subtitle>
  <link href="https://lucas-lxb.github.io/atom.xml" rel="self"/>
  
  <link href="https://lucas-lxb.github.io/"/>
  <updated>2024-09-07T09:22:42.950Z</updated>
  <id>https://lucas-lxb.github.io/</id>
  
  <author>
    <name>Lucas-Lxb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RPC_communciation_mechanism on TVM</title>
    <link href="https://lucas-lxb.github.io/2024/09/07/RPC_communciation_mechanism%20on%20TVM/"/>
    <id>https://lucas-lxb.github.io/2024/09/07/RPC_communciation_mechanism%20on%20TVM/</id>
    <published>2024-09-07T06:26:48.000Z</published>
    <updated>2024-09-07T09:22:42.950Z</updated>
    
    <content type="html"><![CDATA[<h1 style="text-align: center;">    RPC通信机制 </h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>RPC(remote procedure call)远程过程调用，是一种在不同计算机之间的进程间通信的机制。通过RPC，我们可以像调用本地函数一样调用远程函数，简化了分布式系统的开发和维护工作。</p><h1 id="二、RPC基本原理"><a href="#二、RPC基本原理" class="headerlink" title="二、RPC基本原理"></a>二、RPC基本原理</h1><p>RPC的基本工作原理如下：</p><ol><li>调用方将调用请求封装成一个消息，并通过网络发送给远程服务</li><li>远程服务接收到消息后，解析消息并调用相应的函数</li><li>远程函数执行完毕后，将结果封装成消息并发送给调用方</li><li>调用方接收到消息后，解析消息并获取结果</li></ol><p><img                         lazyload                       alt="image"                       data-src="https://cdn.jsdelivr.net/gh/Lucas-Lxb/pictures-picgo/img/RPC%E5%8E%9F%E7%90%86.png"                        alt="RPC原理"                 ></p><h1 id="三、TVM-RPC-通信-自定义RPC框架"><a href="#三、TVM-RPC-通信-自定义RPC框架" class="headerlink" title="三、TVM RPC 通信 (自定义RPC框架)"></a>三、TVM RPC 通信 (自定义RPC框架)</h1><h2 id="1-TVM-RPC通信核心组件"><a href="#1-TVM-RPC通信核心组件" class="headerlink" title="1.TVM RPC通信核心组件"></a>1.TVM RPC通信核心组件</h2><ul><li>RPC Tracker : 跟踪和管理远程设备，记录每个远程设备的状态和位置</li><li>RPC Server : 在远程设备上运行，接受来自客户端的请求并执行任务</li><li>RPC Client : 在本地运行，用于向远程设备发送任务，并接受执行结果</li></ul><h2 id="2-RPC通信流程"><a href="#2-RPC通信流程" class="headerlink" title="2.RPC通信流程"></a>2.RPC通信流程</h2><h3 id="（1）启动-RPC-Tracker"><a href="#（1）启动-RPC-Tracker" class="headerlink" title="（1）启动 RPC Tracker"></a>（1）启动 RPC Tracker</h3><p>RPC Tracker是负责管理所有远程设备的中心节点，它会追踪已经注册的 RPC Server，并允许客户端通过Tracker定位和连接到相应的设备。</p><p>​启动 RPC Tracker的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m tvm.exec.rpc_tracker --host=0.0.0.0 --port=9190</span><br></pre></td></tr></table></figure><h3 id="（2）启动-RPC-Server"><a href="#（2）启动-RPC-Server" class="headerlink" title="（2）启动 RPC Server"></a>（2）启动 RPC Server</h3><p>​在远程设备上（如树莓派、GPU 服务器等），需要启动 RPC Server，它会注册到指定的 RPC Tracker 并等待客户端的任务请求。启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m tvm.exec.rpc_server --tracker=tracker_host:9190 --key=raspberry_pi</span><br></pre></td></tr></table></figure><p>​RPC Server会注册自身到Tracker，成为可用的设备，并接受从客户端发来的任务请求。</p><h3 id="（3）客户端连接RPC-Server"><a href="#（3）客户端连接RPC-Server" class="headerlink" title="（3）客户端连接RPC Server"></a>（3）客户端连接RPC Server</h3><p>​在本地机器上，客户端通过 RPC Tracker 查找和连接到远程设备（RPC Server）。客户端首先连接到 Tracker，然后通过指定的 <code>key</code> 请求连接到特定设备。</p><h3 id="（4）执行远程任务"><a href="#（4）执行远程任务" class="headerlink" title="（4）执行远程任务"></a>（4）执行远程任务</h3><p>​一旦客户端连接到远程设备（通过 RPC Tracker），它可以在该设备上执行远程任务，例如推理或性能调优。可以在远程设备上加载模块并运行。</p><h3 id="（5）结果返回——（自动完成）"><a href="#（5）结果返回——（自动完成）" class="headerlink" title="（5）结果返回——（自动完成）"></a>（5）结果返回——（自动完成）</h3><p>​远程设备（RPC Server）在执行完任务后，会通过网络将结果返回给本地客户端（RPC Client）。这个过程是自动完成的，客户端无需关心底层的网络传输，TVM 的 RPC 框架会处理数据的序列化、传输和反序列化。</p><h2 id="3-TVM-RPC的工作原理"><a href="#3-TVM-RPC的工作原理" class="headerlink" title="3.TVM RPC的工作原理"></a>3.TVM RPC的工作原理</h2><p>TVM 的 RPC 是基于<strong>序列化、网络通信</strong>和<strong>函数调用</strong>机制构建的，其工作原理可以分为以下几个步骤：</p><ol><li><strong>序列化请求</strong>：当客户端请求调用远程设备上的函数时，RPC 框架会将函数名称、参数、设备标识等信息序列化为消息。</li><li><strong>网络传输</strong>：这些消息通过网络发送给远程设备（RPC Server）。RPC Server 监听指定端口，接收到消息后，解析请求。</li><li><strong>执行函数</strong>：RPC Server 解析出要调用的函数名称和参数，在设备上执行该函数。执行过程中使用远程设备的计算资源（如 CPU、GPU 等）。</li><li><strong>序列化结果</strong>：执行完成后，RPC Server 会将结果序列化，并通过网络返回给客户端。</li><li><strong>反序列化结果</strong>：客户端接收到结果后，将其反序列化为可用的 Python 对象，继续后续逻辑。</li></ol><h2 id="4-TVM-RPC常见的使用场景"><a href="#4-TVM-RPC常见的使用场景" class="headerlink" title="4.TVM RPC常见的使用场景"></a>4.TVM RPC常见的使用场景</h2><ol><li><strong>分布式调优</strong>：利用多个远程设备的资源进行分布式自动调优，如在树莓派、GPU集群上调优模型。</li><li><strong>异构计算</strong>：在不同的硬件设备（如CPU、GPU、FPGA等）上执行同一模型进行性能对比和优化。</li><li><strong>远程推理</strong>：将模型部署在远程服务器或嵌入式设备上，客户端通过RPC调用远程推理服务。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 style=&quot;text-align: center;&quot;&gt;    RPC通信机制 &lt;/h1&gt;

&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;RPC(remote </summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://lucas-lxb.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>一生一芯</title>
    <link href="https://lucas-lxb.github.io/2024/08/13/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    <id>https://lucas-lxb.github.io/2024/08/13/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/</id>
    <published>2024-08-13T02:03:32.000Z</published>
    <updated>2024-08-13T03:07:42.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Linux环境搭建"><a href="#一、Linux环境搭建" class="headerlink" title="一、Linux环境搭建"></a>一、Linux环境搭建</h1><h2 id="1-gdb调试"><a href="#1-gdb调试" class="headerlink" title="1.gdb调试"></a>1.gdb调试</h2><span id="more"></span><p>1.gdb -q Filename 进入gdb调试器</p><p>2.（gdb）b 3在第三行添加断点breakpoint</p><p>3.(gdb) run执行程序</p><p>4.(gdb)whatis iNum查看iNum的数据类型</p><p>5.(gdb) c继续执行程序（直到下一个断点或者之后没有断点就运行完整个程序）</p><p>6.(gdb)n一步一步执行程序</p><p>7.(gdb) p iNum输出iNum值（gdb中变量的值是每一步执行之前的数字）</p><h2 id="2-Makefile"><a href="#2-Makefile" class="headerlink" title="2.Makefile"></a>2.Makefile</h2><p>从源码到可执行文件的四个阶段：</p><ul><li>预处理(.c-&gt;.i)<ul><li>gcc -E test.c -o test.i</li></ul><p></p></li><li>编译   (.i     -&gt;    .s)                 得到汇编语言代码<ul><li>gcc -S test.i -o test.s</li></ul></li><li>汇编   (.s    -&gt;    .o)                 得到机器语言代码<ul><li>gcc -c test.s -o test.o</li></ul></li><li>链接   (.o    -&gt;    )                    得到可执行文件<ul><li>gcc test.o -o test</li></ul></li></ul><p>gcc(选项)(参数)：</p><p>​-o：指定生成的输出文件；<br>​-On：n为数字1~3，使用编译优化级别n编译程序；<br>​-E：仅执行编译预处理；<br>​-S：将C代码转换为汇编代码；<br>​-Wall：显示警告信息；<br>​-c：仅执行编译操作，不进行链接操作。</p><h2 id="3-tmux使用"><a href="#3-tmux使用" class="headerlink" title="3.tmux使用"></a>3.tmux使用</h2><p>Ctrl+b,shift+%新建左右窗格</p><p>Ctrl+b,shift+“新建上下窗格</p><p>Ctrl+b,x删除当前窗格</p><h2 id="4-编译nemu的坑"><a href="#4-编译nemu的坑" class="headerlink" title="4.编译nemu的坑"></a>4.编译nemu的坑</h2><p>​make menuconfig命令后出现如下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/scripts/config.mk:20: Warning: .config does not exists!</span><br><span class="line">/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/scripts/config.mk:21: To build the project, first run &#x27;make menuconfig&#x27;.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CC confdata.c</span><br><span class="line"></span><br><span class="line">CC expr.c</span><br><span class="line"></span><br><span class="line">CC preprocess.c</span><br><span class="line"></span><br><span class="line">CC symbol.c</span><br><span class="line"></span><br><span class="line">CC util.c</span><br><span class="line"></span><br><span class="line">YACC build/parser.tab.h</span><br><span class="line">make[1]: bison: 没有那个文件或目录</span><br><span class="line">make[1]: *** [Makefile:27：build/parser.tab.h] 错误 127</span><br><span class="line">make: *** [/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/scripts/config.mk:39：/home/lixuanbo/Desktop/ysyx/ysyx-workbench/nemu/tools/kconfig/build/mconf] 错误 2</span><br></pre></td></tr></table></figure><p>解决方法：要安装词法分析和语法分析工具flex和bison</p><h1 id="二、搭建verilator仿真环境"><a href="#二、搭建verilator仿真环境" class="headerlink" title="二、搭建verilator仿真环境"></a>二、搭建verilator仿真环境</h1><h2 id="1-【一生一芯】搭建verilator仿真环境-老吴家的小阿哲-博客园-cnblogs-com"><a href="#1-【一生一芯】搭建verilator仿真环境-老吴家的小阿哲-博客园-cnblogs-com" class="headerlink" title="1.【一生一芯】搭建verilator仿真环境 - 老吴家的小阿哲 - 博客园 (cnblogs.com)"></a>1.<a class="link"   href="https://www.cnblogs.com/Wishengine/p/17447398.html" >【一生一芯】搭建verilator仿真环境 - 老吴家的小阿哲 - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></h2><h2 id="2-verilator探幽"><a href="#2-verilator探幽" class="headerlink" title="2.verilator探幽"></a>2.verilator探幽</h2><h3 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="(1)一个简单的例子"></a>(1)一个简单的例子</h3><p>1.将<strong>verilog</strong>代码写入文件<code>top.v</code></p><p>2.将**C++**代码写入文件<code>sim_main.cpp</code></p><p>3.使用下面的命令来运行Verilator:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator --cc --exe --build -j <span class="number">0</span> -Wall sim_main<span class="variable">.cpp</span> top<span class="variable">.v</span></span><br></pre></td></tr></table></figure><p>4.使用<strong>.&#x2F;obj_dir&#x2F;Vtop</strong>来运行Verilator生成的可执行程序</p><h3 id="2-稍微复杂的例子"><a href="#2-稍微复杂的例子" class="headerlink" title="(2)稍微复杂的例子"></a>(2)稍微复杂的例子</h3><p>在Verilog中，<code>assign</code> 是一个关键字，用于为信号赋值</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><center><B><font size=5 color=white face="宋体">(一)在C++代码中设置跟踪，创建波形文件</font></B></center><p>1.编写top.v:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top (</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>2.编写main.cpp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated_vcd_c.h&quot;</span> <span class="comment">// 生成vcd文件使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vtop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> &amp;&amp; argc &amp;&amp; argv) &#123;&#125;</span><br><span class="line">    <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VerilatedContext&gt; contextp&#123;new VerilatedContext&#125;; <span class="comment">//创建一个动态分配的 VerilatedContext 对象，并使用 std::unique_ptr 来确保在不再需要时自动释放内存</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Vtop&gt; top&#123;new Vtop&#123;contextp.get()&#125;&#125;;</span><br><span class="line">    contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">    contextp-&gt;traceEverOn(<span class="literal">true</span>); <span class="comment">// 生成波形文件使用，打开追踪功能</span></span><br><span class="line">    VerilatedVcdC* ftp = new VerilatedVcdC; <span class="comment">// vcd对象指针</span></span><br><span class="line">    top-&gt;trace(ftp, <span class="number">0</span>); <span class="comment">// 0层</span></span><br><span class="line">    ftp-&gt;open(<span class="string">&quot;wave.vcd&quot;</span>); <span class="comment">//设置输出的文件wave.vcd</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!contextp-&gt;gotFinish() &amp;&amp; ++flag &lt; <span class="number">20</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = rand() &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b = rand() &amp; <span class="number">1</span>;</span><br><span class="line">        top-&gt;a = a;</span><br><span class="line">        top-&gt;b = b;</span><br><span class="line">        top-&gt;eval();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, f = %d\n&quot;</span>, a, b, top-&gt;f);</span><br><span class="line">        assert(top-&gt;f == (a ^ b));<span class="comment">//验证top-&gt;f == (a ^ b)，若结果为假，程序终止，并输出错误信息</span></span><br><span class="line"></span><br><span class="line">        contextp-&gt;timeInc(<span class="number">1</span>); <span class="comment">// 时间+1，推动仿真时间</span></span><br><span class="line"> </span><br><span class="line">        ftp-&gt;dump(contextp-&gt;time()); <span class="comment">// dump wave    dump 方法通常用于将当前时间的信号状态写入到波形文件中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    top-&gt;final();</span><br><span class="line"></span><br><span class="line">    ftp-&gt;close(); <span class="comment">// 必须有</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用如下命令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator --cc --exe --build -Wall --trace top<span class="variable">.v</span> main<span class="variable">.cpp</span></span><br></pre></td></tr></table></figure><p>4.执行生成的Vtop可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./obj_dir/Vtop</span><br></pre></td></tr></table></figure><p>5.shell观察波形</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gtkwave wave.vcd</span><br></pre></td></tr></table></figure><center><B><font size=5 color=white face="宋体">(二)在Verilog代码中设置跟踪，创建波形文件</font></B></center><p>1.top.v:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top (</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> ($test$plusargs(<span class="string">&quot;trace&quot;</span>) != <span class="number">0</span>) <span class="keyword">begin</span><span class="comment">//在仿真开始时检查命令行参数，如果存在 &quot;trace&quot; 参数，则设置波形文件并将相关的信号状态写入到波形文件中</span></span><br><span class="line">         <span class="built_in">$display</span>(<span class="string">&quot;[%0t] Tracing to wave.vcd...\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">         <span class="built_in">$dumpfile</span>(<span class="string">&quot;wave.vcd&quot;</span>);</span><br><span class="line">         <span class="built_in">$dumpvars</span>();</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;[%0t] Model running...\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>2.main.cpp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vtop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;verilated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> &amp;&amp; argc &amp;&amp; argv) &#123;&#125;</span><br><span class="line">    <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VerilatedContext&gt; contextp&#123;new VerilatedContext&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Vtop&gt; top&#123;new Vtop&#123;contextp.get()&#125;&#125;;</span><br><span class="line">    contextp-&gt;commandArgs(argc, argv);</span><br><span class="line">    contextp-&gt;traceEverOn(<span class="literal">true</span>); <span class="comment">// 生成波形文件使用，打开追踪功能</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!contextp-&gt;gotFinish() &amp;&amp; ++flag &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = rand() &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b = rand() &amp; <span class="number">1</span>;</span><br><span class="line">        top-&gt;a = a;</span><br><span class="line">        top-&gt;b = b;</span><br><span class="line">        top-&gt;eval();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, f = %d\n&quot;</span>, a, b, top-&gt;f);</span><br><span class="line">        assert(top-&gt;f == (a ^ b));</span><br><span class="line"></span><br><span class="line">        contextp-&gt;timeInc(<span class="number">1</span>); <span class="comment">// 时间+1，推动仿真时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    top-&gt;final();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用如下命令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator --cc --exe --build -Wall --trace top<span class="variable">.v</span> main<span class="variable">.cpp</span></span><br></pre></td></tr></table></figure><p>4.执行生成的Vtop可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./obj_dir/Vtop</span><br></pre></td></tr></table></figure><p>5.shell观察波形</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gtkwave wave.vcd</span><br></pre></td></tr></table></figure><h1 id="三、Linux入门教程"><a href="#三、Linux入门教程" class="headerlink" title="三、Linux入门教程"></a>三、Linux入门教程</h1><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><ul><li><p>find . -name “*.[c]” ———查找当前目录下的.c文件</p></li><li><p>grep “\bint i\b”  a.c   查找文件中定义变量i的位置—————-模式”\bint i\b”包含了单词边界锚点（<code>\b</code>）在”int i”周围。这些锚点指定”int i”应该是一个完整的单词，而不是更大单词的一部分。</p></li><li><p>wc     a.c  返回该文件的行数单词数字符数要求为文本文件</p></li><li><p>cpsourcedestination     复制命令      把左边文件的内容复制到右边</p></li></ul><h2 id="2-Linuxvs-Windows"><a href="#2-Linuxvs-Windows" class="headerlink" title="2.Linuxvs.Windows"></a>2.Linuxvs.Windows</h2><h3 id="1-有些简单的事Windows-GUI反而做不好"><a href="#1-有些简单的事Windows-GUI反而做不好" class="headerlink" title="1.有些简单的事Windows GUI反而做不好"></a>1.有些简单的事Windows GUI反而做不好</h3><p>比较两个文件是否相同</p><p>Linux的解决方案：</p><ul><li><p>文本文件的解决方案</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdifffile1file2 </span><br></pre></td></tr></table></figure></li><li><p>非文本文件的解决方案</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">difffile1file2</span><br></pre></td></tr></table></figure></li><li><p>很大的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sumfile1file2</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-有些复杂的事Windows-GUI几乎做不了"><a href="#2-有些复杂的事Windows-GUI几乎做不了" class="headerlink" title="2.有些复杂的事Windows GUI几乎做不了"></a>2.有些复杂的事Windows GUI几乎做不了</h3><p>列出一个项目中所有被包含的头文件</p><p>Linux的解决方案：通过管道进行解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find.-name  &quot;*.[ch]&quot;|xargscat|grep  &quot;^#include&quot;  |sort|uniq</span><br></pre></td></tr></table></figure><h2 id="3-工具如何运行"><a href="#3-工具如何运行" class="headerlink" title="3.工具如何运行"></a>3.工具如何运行</h2><h3 id="1-一个重要的踪迹工具：strace"><a href="#1-一个重要的踪迹工具：strace" class="headerlink" title="(1)一个重要的踪迹工具：strace"></a>(1)一个重要的踪迹工具：strace</h3><ul><li>systemcall strace,记录程序运行过程中的系统调用信息</li><li>系统调用：一个由操作系统来执行的特殊的函数调用</li></ul><p>在<em>Linux中</em>,<em>Path</em>是一个非常重要的概念,它是用来定位系统中各种可执行文件、命令和脚本的路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace bash -c <span class="string">&quot;PATH = &#x27;aaa:bbb:ccc&#x27; ls&quot;</span><span class="comment">//整个命令的目的是使用strace追踪Bash shell在将PATH环境变量设置为&#x27;aaa:bbb:ccc&#x27;后执行ls命令时所发起的系统调用。</span></span><br></pre></td></tr></table></figure><h3 id="2-用户与man交互"><a href="#2-用户与man交互" class="headerlink" title="(2)用户与man交互"></a>(2)用户与man交互</h3><p>在 <code>man</code> 命令下进行手册的阅读时，可以使用一些快捷键和搜索命令来进行快速搜索。以下是一些建议：</p><p><strong>使用<code>/</code>进行搜索：</strong></p><ul><li><pre><code>- 在 `man` 页面中按 `/` 键，然后输入你要搜索的关键词，按回车。`man` 会定位到第一个匹配的文本。- 按 `n` 键继续查找下一个匹配，按 `N` 键查找上一个匹配。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### (3)强大的shell</span><br><span class="line"></span><br><span class="line">1.通配符*（任意长度的任意字符串）|？（任意一个字符）|[...](集合中的任意一个字符)</span><br><span class="line"></span><br><span class="line">2.括号扩展&#123;...&#125;（例：echo Hello-&#123;a,bb,ccc&#125;-&#123;1,2&#125;!）---------&gt;</span><br><span class="line"></span><br><span class="line">------&gt;输出结果为：Hello-a-1! Hello-a-2! Hello-bb-1! Hello-bb-2! Hello-ccc-1! Hello-ccc-2!</span><br><span class="line"></span><br><span class="line">### (3)使用alias为常用命令设置别名</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">alias ls = &quot;ls --color&quot;</span><br><span class="line">    可以写入~/.bashrc文件，打开终端时生效，无需重复设置：source ~/.bashrc</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="4-任务管理"><a href="#4-任务管理" class="headerlink" title="(4)任务管理"></a>(4)任务管理</h3><p>1.查看任务管理器：ps aux——-&gt;   静态命令，只显示在命令运行时的瞬时数据。</p><ul><li><code>ps</code> 是一个用于报告当前系统进程信息的命令</li><li><code>aux</code> 选项表示以详细的方式显示所有用户的所有进程<ul><li>提供了基本的进程信息，如进程ID（PID）、CPU利用率、内存使用、启动时间等</li></ul></li></ul><p>2.<code>top</code> 提供了实时动态更新的系统监视器</p><p>3.<code>htop</code> 是 <code>top</code> 的增强版，提供了更直观的界面和更多功能</p><h3 id="5-输入输出重定向"><a href="#5-输入输出重定向" class="headerlink" title="(5)输入输出重定向"></a>(5)输入输出重定向</h3><p>已知Linux上的程序在运行时默认打开了3个文件，通过“文件描述符”来编号：</p><ul><li>0号文件 - 标准输入（默认为当前终端）</li><li>1号文件 - 标准输出（默认为当前终端）</li><li>2号文件 - 标准错误（默认为当前终端）</li></ul><p>1.向文件追加输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt;&gt; result.txt</span><br></pre></td></tr></table></figure><p>2.将标准错误重定向到文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 2&gt; /dev/null...</span><br></pre></td></tr></table></figure><p>3.将标准输入重定向到文件，无需手动输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> &lt; result.txt</span><br></pre></td></tr></table></figure><h3 id="6-管道：工具间组合的秘诀"><a href="#6-管道：工具间组合的秘诀" class="headerlink" title="(6)管道：工具间组合的秘诀"></a>(6)管道：工具间组合的秘诀</h3><p>管道 &#x3D; 一个用于连接程序间输入输出的缓冲区</p><p>xargs:一个特殊的命令，可以将标准输入转变为命令的参数</p><ul><li>自制CPU主频监视器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 &quot;cat /proc/cpuinfo | grep MHz | awk&#x27;&#123;print \$1NR\$3\$4\$2&#125;&#x27;&quot;</span><br></pre></td></tr></table></figure><p>Linux中可执行文件为ELF文件</p><h2 id="4-如何学习Linux"><a href="#4-如何学习Linux" class="headerlink" title="4.如何学习Linux"></a>4.如何学习Linux</h2><p>最重要的Linux命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">man</span><br><span class="line"></span><br><span class="line">man man - 学习如何RTFM</span><br><span class="line">man 3 printf-学习如何使用库函数printf</span><br><span class="line">man -k xxx检索含有关键字含有xxx的命令</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、Linux环境搭建&quot;&gt;&lt;a href=&quot;#一、Linux环境搭建&quot; class=&quot;headerlink&quot; title=&quot;一、Linux环境搭建&quot;&gt;&lt;/a&gt;一、Linux环境搭建&lt;/h1&gt;&lt;h2 id=&quot;1-gdb调试&quot;&gt;&lt;a href=&quot;#1-gdb调试&quot; class=&quot;headerlink&quot; title=&quot;1.gdb调试&quot;&gt;&lt;/a&gt;1.gdb调试&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://lucas-lxb.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://lucas-lxb.github.io/2024/08/13/blog%E6%B3%A8%E9%87%8A/"/>
    <id>https://lucas-lxb.github.io/2024/08/13/blog%E6%B3%A8%E9%87%8A/</id>
    <published>2024-08-13T01:39:27.000Z</published>
    <updated>2024-08-15T02:54:14.288Z</updated>
    
    <content type="html"><![CDATA[<p><img                         lazyload                       alt="image"                       data-src="https://cdn.jsdelivr.net/gh/Lucas-Lxb/pictures-picgo/img/R-C.jpg"                        alt="R-C"                 ></p><h1 id="一、文章开头设置："><a href="#一、文章开头设置：" class="headerlink" title="一、文章开头设置："></a>一、文章开头设置：</h1><p>文章 .md 文件最上方以 — 分隔的区域，用于设置文章的变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.password: 123456  </span><br><span class="line">设置文章访问密码</span><br><span class="line">  </span><br><span class="line">2.code_block_shrink:  false     </span><br><span class="line">代码块不自动收缩</span><br><span class="line">   </span><br><span class="line">3.excerpt: 这是《Keep 主题使用指南》的摘要信息......        </span><br><span class="line">给文章单独设置摘要信息</span><br><span class="line">    </span><br><span class="line">4.&lt;!-- more --&gt;   ：                                      </span><br><span class="line">&lt;!-- more --&gt; 之前的内容将会被视为摘要，  </span><br><span class="line"> 并在 Home（首页）将这段内容的 Markdown 排版格式完整显示出来</span><br><span class="line"> </span><br><span class="line">5.mathjax: true    </span><br><span class="line">    在文章中显示数学公式</span><br></pre></td></tr></table></figure><h1 id="二、文章重要显示内容："><a href="#二、文章重要显示内容：" class="headerlink" title="二、文章重要显示内容："></a>二、文章重要显示内容：</h1><blockquote class="warning">    <h2>依然连仿真框架都没有, 真寒酸</h2>    <p>我们之所以设置这部分的实验内容，是为了让大家知道...</p>    <ul>        <li>遇到系统性的bug，肯定消不出去...</li>        <li>离开了讲义，就什么都做不了...</li>        <li>一个很现实的场景是...</li>    </ul></blockquote>![image-20240814085831707](https://cdn.jsdelivr.net/gh/Lucas-Lxb/pictures-picgo/img/image-20240814085831707.png)<blockquote class="command">    <h3>如果你想使用Chisel</h3>    <code>        cd ysyx-workbench<br>        bash init.sh npc-chisel    </code>    <p>上述命令会将 npc 目录中的文件换成一个Chisel开发环境...</p></blockquote><p><img                         lazyload                       alt="image"                       data-src="https://cdn.jsdelivr.net/gh/Lucas-Lxb/pictures-picgo/img/image-20240813174835625.png"                        alt="image-20240813174835625"                 ></p><h1 id="三、博客编写和部署命令"><a href="#三、博客编写和部署命令" class="headerlink" title="三、博客编写和部署命令"></a>三、博客编写和部署命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new title</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;https://cdn.jsdelivr.net/gh/Lu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>String类的特性</title>
    <link href="https://lucas-lxb.github.io/2024/08/04/String%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>https://lucas-lxb.github.io/2024/08/04/String%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7/</id>
    <published>2024-08-04T02:25:46.000Z</published>
    <updated>2024-08-13T02:45:09.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>​下面程序运行的结果是什么？尝试画出内存布局图。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExercise02</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;lxb&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str,<span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringExercise02</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExercise02</span>();</span><br><span class="line">        ex.change(ex.str,ex.ch); <span class="comment">//①</span></span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>);</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="一、方法执行时分析"><a href="#一、方法执行时分析" class="headerlink" title="一、方法执行时分析"></a>一、方法执行时分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str,<span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;java&quot;</span>;<span class="comment">//代码②</span></span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;<span class="comment">//代码③</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​在执行代码①处时，ex.str 和 ex.ch 被传递给change方法，由于二者均为引用数据类型(数组类型和String类型)，因而传入 change 方法时，会直接使得形参 str 指向ex对象的 str 和 ch 属性在堆中的地址，后开始执行该方法：</p><p>由于代码②处将字符串常量赋值给 str，因而会在常量池中创建 “java” 对象，并将 str 指向该处于常量池中的对象，因而上述图中的虚线断裂，箭头重新指向常量池中的 “java” ；</p><p>由于 ch 并未重新赋值，而是直接在原来的基础上对原数组进行修改，因而ch的指向不改变，但是该数组的内容发生改变。</p><h3 id="二、方法执行后分析"><a href="#二、方法执行后分析" class="headerlink" title="二、方法执行后分析"></a>二、方法执行后分析</h3><p>​由于在执行该方法时 JVM 会在栈中创建 change 栈，在该方法执行完毕之后进行销毁，因此该方法的形参 str 和 ch 均被销毁，并返回主栈。此时 ex 对象的 str 属性并未改变，为 “lxb” ；ch 属性则发生变化，变为 “hava” ,因而最终输出为 lxb and hava.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;​	下面程序运行的结果是什么？尝试画出内存布局图。&lt;/p&gt;</summary>
    
    
    
    <category term="码农搬砖" scheme="https://lucas-lxb.github.io/categories/%E7%A0%81%E5%86%9C%E6%90%AC%E7%A0%96/"/>
    
    
    <category term="Java基础" scheme="https://lucas-lxb.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>树莓派opencv-python踩坑记录</title>
    <link href="https://lucas-lxb.github.io/2024/04/04/%E6%A0%91%E8%8E%93%E6%B4%BEopencv-python%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://lucas-lxb.github.io/2024/04/04/%E6%A0%91%E8%8E%93%E6%B4%BEopencv-python%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2024-04-04T05:13:07.000Z</published>
    <updated>2024-08-13T02:45:39.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突"><a href="#1-’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突" class="headerlink" title="1.’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突"></a>1.’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突</h1><p>修改为：安装版本为 python3.8 与 Opencv-python4.1.2.</p><span id="more"></span><h1 id="2-使用pip安装软件包时出现SSL验证失败问题：pip版本在20-3以上时会出现此错误"><a href="#2-使用pip安装软件包时出现SSL验证失败问题：pip版本在20-3以上时会出现此错误" class="headerlink" title="2.使用pip安装软件包时出现SSL验证失败问题：pip版本在20.3以上时会出现此错误"></a>2.使用pip安装软件包时出现SSL验证失败问题：pip版本在20.3以上时会出现此错误</h1><p>修改：</p><p>法一:下载pip版本为20.2.4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install pip==20.2.4 -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com</span><br><span class="line">python -m pip install pip==20.2.4 -i http://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com</span><br></pre></td></tr></table></figure><p>法二：修改pip源</p><p>修改为（以下任意一项） ———————–由于网速限制可能要多试几遍（我试了很多遍…….）</p><ul><li><pre><code>http://mirrors.aliyun.com/pypi/simple/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  http://pypi.douban.com/simple</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>注：树莓派所安装操作系统为DeBian 11.</p><h1 id="3-apt-get修改国内源（23-10-mantic版本）"><a href="#3-apt-get修改国内源（23-10-mantic版本）" class="headerlink" title="3.apt-get修改国内源（23.10 mantic版本）"></a>3.apt-get修改国内源（23.10 mantic版本）</h1><ol><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ mantic-security main restricted universe multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ mantic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-proposed main restricted universe multiverse</span><br><span class="line"># # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ mantic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><ol start="2"><li>无法获得锁：&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-fronted</li></ol><p>解决方案:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/dpkg/lock-frontend</span><br><span class="line">sudo rm /var/lib/dpkg/lock</span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br></pre></td></tr></table></figure><p>都运行一遍，具体也不知道哪条起了作用。</p><p>出现以下错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error:Could <span class="keyword">not</span> build wheels <span class="keyword">for</span> opencv-python ,which <span class="keyword">is</span> required to install pyproject.toml-based projects</span><br><span class="line">------&gt;安装poetry</span><br><span class="line">------&gt;运行poetry init命令  <span class="comment">#获得pyproject.toml文件</span></span><br><span class="line">------&gt;运行poetry install命令 <span class="comment">#得到项目内文件的依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Poetry 是一个用于管理 Python 项目依赖、虚拟环境和打包发布的工具。它通过一个名为 `pyproject.toml` 的配置文件来管理项目。使用 Poetry，你可以方便地定义项目的依赖关系、版本约束和脚本命令，并且它提供了一组命令来执行各种常见任务，例如安装依赖、创建虚拟环境、构建项目等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Poetry 是一个用于管理 Python 项目依赖、虚拟环境和打包发布的工具。它通过一个名为 pyproject.toml 的配置文件来管理项目。使用 Poetry，你可以方便地定义项目的依赖关系、版本约束和脚本命令，并且它提供了一组命令来执行各种常见任务，例如安装依赖、创建虚拟环境、构建项目等。</span><br><span class="line"></span><br><span class="line">以下是一些常用的 Poetry 命令：</span><br><span class="line"></span><br><span class="line">poetry init 是一个用于初始化 Python 项目的命令，它使用 Poetry 工具。Poetry 是一个 Python 包管理工具和项目管理工具，它可以帮助你管理项目依赖关系和构建工具。</span><br><span class="line"></span><br><span class="line"><span class="comment">#当你运行 poetry init 命令时，它会引导你完成创建一个新的 Python 项目的过程。它会询问一些问题，如项目名称、版本、作者、项目依#赖等，并生成一个 pyproject.toml 文件，用于描述你的项目和其依赖关系。</span></span><br><span class="line"></span><br><span class="line">poetry new: 创建一个新的 Python 项目。</span><br><span class="line"></span><br><span class="line">poetry install: 安装项目的依赖。</span><br><span class="line"></span><br><span class="line">poetry add: 添加新的依赖项到项目。</span><br><span class="line"></span><br><span class="line">poetry remove: 从项目中移除依赖项。</span><br><span class="line"></span><br><span class="line">poetry update: 更新项目的依赖项。</span><br><span class="line"></span><br><span class="line">poetry run: 在虚拟环境中运行项目中定义的脚本命令。</span><br><span class="line"></span><br><span class="line">poetry shell: 进入项目的虚拟环境。</span><br><span class="line"></span><br><span class="line">poetry build: 构建项目。</span><br><span class="line"></span><br><span class="line">poetry publish: 发布项目到包索引。</span><br><span class="line"></span><br><span class="line">poetry config: 配置 Poetry 的设置。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突&quot;&gt;&lt;a href=&quot;#1-’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突&quot; class=&quot;headerlink&quot; title=&quot;1.’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突&quot;&gt;&lt;/a&gt;1.’xcb’插件检测得到但是不可加载：大概率是opencv与python版本冲突&lt;/h1&gt;&lt;p&gt;修改为：安装版本为 python3.8 与 Opencv-python4.1.2.&lt;/p&gt;</summary>
    
    
    
    <category term="折腾Linux" scheme="https://lucas-lxb.github.io/categories/%E6%8A%98%E8%85%BELinux/"/>
    
    
    <category term="树莓派" scheme="https://lucas-lxb.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>计算理论导引</title>
    <link href="https://lucas-lxb.github.io/2024/03/18/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AF%BC%E5%BC%95/"/>
    <id>https://lucas-lxb.github.io/2024/03/18/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%AF%BC%E5%BC%95/</id>
    <published>2024-03-18T08:09:40.000Z</published>
    <updated>2024-08-13T07:33:42.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分自动机与语言"><a href="#第一部分自动机与语言" class="headerlink" title="第一部分自动机与语言"></a>第一部分自动机与语言</h1><hr><span id="more"></span><h2 id="第一章正则语言"><a href="#第一章正则语言" class="headerlink" title="第一章正则语言"></a>第一章正则语言</h2><h3 id="1-1有穷自动机"><a href="#1-1有穷自动机" class="headerlink" title="1.1有穷自动机"></a>1.1有穷自动机</h3><h4 id="1-1-1-有穷自动机的形式化定义"><a href="#1-1-1-有穷自动机的形式化定义" class="headerlink" title="1.1.1 有穷自动机的形式化定义"></a>1.1.1 有穷自动机的形式化定义</h4><p>有穷自动机是一个5元组（Q，Σ，δ，q0，F）</p><ol><li><p>Q是一个有穷集合，称为状态集</p></li><li><p>Σ是一个有穷集合，称为字母表</p></li><li><p>δ：Q×Σ-&gt;Q，是转移函数</p></li><li><p>q0∈Q，是起始状态</p></li><li><p>F含于Q，是接受状态集</p></li></ol><h4 id="1-1-2计算的形式化定义"><a href="#1-1-2计算的形式化定义" class="headerlink" title="1.1.2计算的形式化定义"></a>1.1.2计算的形式化定义</h4><p>设M &#x3D; （Q，Σ，δ，q0，F）是一台有穷自动机，W &#x3D; W1W2W3…Wn是一个字符串并且其中任意wi是字母表Σ的成员。如果存在Q中的状态序列r0,r1,…,rn,满足下述条件：</p><ol><li>r0 &#x3D; q0机器从开始状态开始</li><li>δ（ri,W(i + 1)） &#x3D; r(i + 1),i &#x3D; 0,…,n - 1            机器按照转移函数从一个状态到一个状态</li><li>rn∈F                                                                如果机器结束在接受状态，则接受它的输入</li></ol><p>则M接受串W</p><p><strong><u>如果A &#x3D; {W | M接受W}，则称M识别语言A</u></strong></p><p>如果一个语言被一台有穷自动机识别，则称它为正则语言。</p><h4 id="1-1-3设计有穷自动机"><a href="#1-1-3设计有穷自动机" class="headerlink" title="1.1.3设计有穷自动机"></a>1.1.3设计有穷自动机</h4><ol><li>给每一种可能的字符串信息设计一个状态</li><li>通过观察如何根据读到的符号从一种可能性到另一种可能性来设计转移</li><li>接下来，把起始状态设置为对应于到现在为止还没有看到与任何符号（空串ε）相关联的可能性的状态</li></ol><h4 id="1-1-4正则运算"><a href="#1-1-4正则运算" class="headerlink" title="1.1.4正则运算"></a>1.1.4正则运算</h4><p>设A和B是两个语言，定义正则运算并、连接和星号如下：</p><ul><li>并：A∪B &#x3D; {x | x∈A或x∈B}</li><li>连接：A▪B &#x3D; {xy | x∈A且y∈B}</li><li>星号：A* &#x3D; {x1x2x3…xk | k &gt;&#x3D; 0 且每一个xi∈A}          ——&gt;一元运算</li></ul><p>一般来说，如果把某种运算应用于一个对象集合的成员得到的对象仍在这个集合中，则称这个对象集合在该运算下封闭。</p><h3 id="1-2非确定性"><a href="#1-2非确定性" class="headerlink" title="1.2非确定性"></a>1.2非确定性</h3><p>非确定性是确定性的推广-&gt; 因此每一台确定性有穷自动机自动地是一台非确定性有穷自动机</p><p>NFA与DFA的不同点：</p><ol><li>在NFA中，一个状态对应于字母表中的每一个符号可能有0个、1个或多个射出的箭头</li><li>在DFA上，转移箭头上的标号是取自字母表中的符号；NFA中则可以取自ε</li><li>一般来说，NFA的箭头可以标记字母表中的符号或ε。从一个状态可能射出0个、1个或多个带有标号ε的箭头</li></ol><p>可以把非确定性看做是若干独立的“过程”或“线程”，即能同时运行的一类**<u>并行运算</u>**，如果这些子过程至少有一个接受，那么整个计算接受。</p><h4 id="1-2-1-非确定性有穷自动机的形式化定义"><a href="#1-2-1-非确定性有穷自动机的形式化定义" class="headerlink" title="1.2.1 非确定性有穷自动机的形式化定义"></a>1.2.1 非确定性有穷自动机的形式化定义</h4><p>非确定性有穷自动机是一个5元组（Q，Σ，δ，q0，F）</p><ol><li>Q是一个有穷集合，称为状态集</li><li>Σ是一个有穷集合，称为字母表</li><li>δ：Q×（Σ∪{ε}）-&gt;（Q的幂集），是转移函数</li><li>q0∈Q，是起始状态</li></ol><h4 id="1-2-1NFA与DFA的等价性"><a href="#1-2-1NFA与DFA的等价性" class="headerlink" title="1.2.1NFA与DFA的等价性"></a>1.2.1NFA与DFA的等价性</h4><blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一部分自动机与语言&quot;&gt;&lt;a href=&quot;#第一部分自动机与语言&quot; class=&quot;headerlink&quot; title=&quot;第一部分	自动机与语言&quot;&gt;&lt;/a&gt;第一部分	自动机与语言&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="理论知识" scheme="https://lucas-lxb.github.io/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="计算理论" scheme="https://lucas-lxb.github.io/tags/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
</feed>
